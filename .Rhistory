?require()
?Sys.sleep
z <- matrix(1:9, ncol=3)
z
z[,2] <- hello
z[,2] <- "hello"
z
colnames(z[,2] )<- "hello"
colnames(z )<- "hello"
z = 1:3
paste("batch", z)
n <- paste("batch", z)
colnames(z) <- n
z <- matrix(1:9, ncol=3)
colnames(z) <- n
z
o <- NULL
o <- cbind(o, 2)
o
readInData <- function(batchNumber) {
# Required packages
require(httr)
require(jsonlite)
require(RCurl)
length_batch <- length(batchNumber)
# try_count will count how many times function tries to connect to server
# Will try five times before giving up
try_count <- 0
#https://sentimentit.com/api/batches/1/download.json
while(try_count <= 5){
# TODO: Currently code resets output matrix each try. I am unsure if it should
# keep batch numbers which work successfully.
output_matrix <- NULL
for (i in 1:length_batch){
output<- GET(paste0('https://sentimentit.herokuapp.com/api/batches/',batchNumber[i],'/download.json'))
myurl <- rawToChar(as.raw(output$content))
myurl <- strsplit(myurl,'\"')[[1]][4]
x <- getURL(myurl)
data <- read.csv(text = x)
output_matrix <- cbind(output_matrix, data)
}
# check if output is correct. If not function tries again.
if(nrow(output_matrix) > 1 & ncol(output_matrix) == length_batch ) {
try_count <- 6
} else {
print("Can not connect to server. Will try again in two minutes.")
try_count <- try_count + 1
Sys.sleep(120)
}
}
if(nrow(output_matrix) < 1 | ncol(output_matrix) != length_batch){
return("Could not connect to server now. Please check your batch numbers are accurate and try again later.")
}
batch_names <- paste("batch ", batchNumber)
colnames(output_matrix) <- batch_names
return(output_matrix)
}
b <- 204:208
readInData(b)
readInData(204)
#####
readInData <- function(batchNumber) {
# Required packages
require(httr)
require(jsonlite)
require(RCurl)
length_batch <- length(batchNumber)
# try_count will count how many times function tries to connect to server
# Will try five times before giving up
try_count <- 0
#https://sentimentit.com/api/batches/1/download.json
while(try_count <= 5){
# TODO: Currently code resets output matrix each try. I am unsure if it should
# keep batch numbers which work successfully.
output_matrix <- NULL
for (i in 1:length_batch){
output<- GET(paste0('https://sentimentit.herokuapp.com/api/batches/',batchNumber[i],'/download.json'))
myurl <- rawToChar(as.raw(output$content))
myurl <- strsplit(myurl,'\"')[[1]][4]
x <- getURL(myurl)
data <- read.csv(text = x)
output_matrix <- cbind(output_matrix, data)
}
# check if output is correct. If not function tries again.
if(nrow(output_matrix[1,]) > 1 & ncol(output_matrix) == length_batch ) {
try_count <- 6
} else {
print("Can not connect to server. Will try again in two minutes.")
try_count <- try_count + 1
Sys.sleep(120)
}
}
if(nrow(output_matrix[1,]) < 1 | ncol(output_matrix) != length_batch){
return("Could not connect to server now. Please check your batch numbers are accurate and try again later.")
}
batch_names <- paste("batch ", batchNumber)
colnames(output_matrix) <- batch_names
return(output_matrix)
}
readInData(204)
library(Rcpp)
rm(list=ls())
library(Rcpp)
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add
## Note that I have to declare the "type" for the output, the inputs, and local variables
add(1,2,3)
add
cppFunction('int add(int x, int y, int z) {
int sum = x + y + z;
return sum;
}')
add(1,2,3)
add(2.1, 2.4, 5.2)
addR<-function(x, y, z){
return(x+y+z)
}
addR
addR(1,2,3)
addR(2.1, 2.4, 5.2)
addR(c(2.1, 2.2), c(1.9, 1.8), c(5, 5))
library(microbenchmark)
stupidSum<-function(x){
output<-NULL
for(i in 1:length(x)){
output<-output+x[i]
}
return(output)
}
stupidSum(runif(10000000))
cppFunction('double stupidSumCpp(NumericVector x) {
int n = x.size();
double total=0;
for(int i=0; i<n; ++i) {
total += x[i];
}
return total;
}')
