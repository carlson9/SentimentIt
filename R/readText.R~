#' Reads in text, posts the text to the server, and returns the document IDs after saving the result to a new table.
#'
#' Find/create documents and retrieve ids.
#'
#' @param email The researcher's email associated with the SentimentIt account.
#' @param passwork The researcher's password associated with the SentimentIt account.
#' @param read_documents_from The file path the data will be drawn form, or a vector of text.
#' @param write_documents_to The file path to write the original data, merged with the document IDs. Default is NULL and the results will not be saved, but only returned.
#' @param what Argument passed to scan() function. Default is text. Only needed when index is NULL.
#' @param sep Argument passed to read.table() function. Default is line break. Only needed when index is not NULL.
#' @param quiet Argument passed to scan(). Default is TRUE. Only needed when index is NULL.
#' @param index The index number of the table to extract the text from, or the name of the column. Default is NULL, indicating the text was not sent in a table.
#' @param which_source Source used within SentimentIt server assoicated with document uploads. Only used for later reference. Default is apiR.
#' 
#' @return List of ids corresponding to documents sent.
#'
#' @seealso \code{\link{createTasksTimed}}, \code{\link{batchesWrapper}}, \code{\link{checkCert}},
#' \code{\link{checkWorkers}},\code{\link{createBatches}},\code{\link{createCert}},\code{\link{createTasks}}, 
#' \code{\link{createPairwise}}, \code{\link{extractCoef}},\code{\link{fitStan}},\code{\link{fitStanHier}},
#' \code{\link{givetakeCert}},\code{\link{makeCompsSep}},\code{\link{readInData}}, \code{\link{readText}},
#' \code{\link{repostExpired}},\code{\link{revokeCert}}, \code{\link{sentimentIt}}, \code{\link{batchStatus}},
#' \code{\link{extractCoef}}
#' @author David Carlson
#' @rdname readText
#' @export
readText <- function(email, password, read_documents_from, write_documents_to=NULL, what='character', sep='\n', quiet=TRUE, index=NULL, which_source='apiR', ...){
  if(!is.null(index)){
    if(!is.character(read_documents_from)){
      hold.table = read_documents_from
    } else {
      hold.table <- read.table(file=read_documents_from, sep=sep)
    }
    textToSend <- hold.table[,index]
  }else textToSend <- scan(file=read_documents_from, what=what, sep=sep, quiet=quiet)
  auth_token <- authenticate(email, password)
  args <- mapply(function(x,y) list(text=x, source=y), textToSend, which_source, SIMPLIFY=FALSE, USE.NAMES=FALSE)
  args$auth_token=auth_token
  #auth_token <- as.name(auth_token)
  args <- toJSON(list("documents"=args,"auth_token"=auth_token), auto_unbox=TRUE, force=TRUE)
  #position <- c(regexec('"auth_token":".*"', args)[[1]][1] + 14, regexec('"auth_token":".*"', args)[[1]][1] + attr(regexec('"auth_token":".*"', args)[[1]], 'match.length')-2)
  #substr(args, position[1]-1, position[2]+1) <- paste0(" ",substr(args, position[1], position[2])," ")
  #args <- sub(paste0("^(.{",position[2],"})(.)(.*$)"), "\\1\\3", args)
  mypost <- POST('https://www.sentimentit.com/api/documents/find_or_create.json',
                 body = args, content_type_json(),
                 encode='json')
  ids <- unlist(fromJSON(rawToChar(as.raw(mypost$content))))
  textToSend <- gsub('\t',' ', textToSend)
  if(is.null(index)){
    if(!is.null(write_documents_to)) write.table(cbind(textToSend, ids), write_documents_to, sep='\t', row.names=FALSE)
    return(cbind(textToSend, ids))
  }else{
    hold.table[,index] <- textToSend
    if(!is.null(write_documents_to)) write.table(cbind(hold.table, ids), write_documents_to, sep='\t', row.names=FALSE)
    return(cbind(hold.table, ids))
  }
}
